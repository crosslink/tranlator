/*
 * article_reader.cpp
 *
 *  Created on: Apr 24, 2012
 *      Author: monfee
 */

#include "article_reader.h"

#include <time.h>
#include <stdio.h>
#include <string.h>

#include <string>
#include <iostream>
#include <exception>

using namespace std;

article_reader::article_reader(const char *file) {
	current_token.start = NULL;
	current_token.length = 0;
}

article_reader::~article_reader() {

}

/*
 * process xml file by each element
 */

token_string *article_reader::get_next_token() {
	process();
	return &current_token;
}

void article_reader::copy_to_next_token(article_writer& writer) {
//	content.a
}

token_string * article_reader::get_next_token(article_writer& the_writer) {
	writer = &the_writer;

	progress = TITLE;
	process();
	return &current_token;
}

void article_reader::process() {

	switch (progress) {
	case TITLE:
		this->read_title();
		++progress;
		break;
	case CATEGORIES:
		this->read_categories();
		++progress;
		break;
	case MAIN_TEXT:
		this->read_main_text();
		++progress;
		break;
	case NOTES:
//		this->skip_notes();
		this->read_notes();
		++progress;
		break;
	case REFERENCES:
		++progress;
		this->skip_references();
		break;
	case EXTERNAL_LINKS:
		this->skip_external_links();
		++progress;
		break;
	}
}

void article_reader::read() {
	article::read();
	current = content.c_str();
}

void article_reader::read_title() {
	const char *start, *end = NULL;
	static const char *TITLE_TAG_START = "<title>";
	static const char *TITLE_TAG_END = "</title>";

	start = strstr(current, TITLE_TAG_START);
	if (start != NULL) {
		start += strlen(TITLE_TAG_START);
		current_token.start = start;
		copy_to_current(current, start);

		end = strstr(start, TITLE_TAG_END);
		if (end != NULL) {
			end += strlen(TITLE_TAG_END);
			current_token.length = end - start;

//			start = strchr(start, '"');
//			++start;
//			end =  strchr(start, '"');
		}
	}

	if (start == NULL || end == NULL) {
		string msg = string("The article is not well-formed in the article title: ") + file_path;
		throw exception(msg.c_str());
	}
}

void article_reader::read_categories() {

}

void article_reader::read_main_text() {

}

void article_reader::skip_notes() {

}

void article_reader::skip_references() {

}

void article_reader::read_notes() {

}

void article_reader::reconstruct_comment() {
	const char *start, *end = NULL;
	static const char *COMMENT_TAG_START = "<!--";
	static const char *COMMENT_TAG_END = "-->";


//	time_t t = time(0);
//	tm* lt = localtime(t);
//	char date[11];
//	sprintf(date, "%02d/%02d/%04d", lt->tm_mday, lt->tm_mon + 1, lt->year +
//	1900);


	start = strstr(current, COMMENT_TAG_START);
	if (start != NULL) {
//		start += strlen(COMMENT_TAG_START);
		end = strstr(start, COMMENT_TAG_END);
		if (end != NULL) {
			end += strlen(COMMENT_TAG_END);

//			start = strchr(start, '"');
//			++start;
//			end =  strchr(start, '"');
		}
	}

	if (start != NULL) {
		copy_to_current(current, start);
		create_comment();
		current = start;

		if (end != NULL) {
			current = end;
		}
		else {
			string msg = string("The article is not well-formed in the comment: ") + file_path;
			throw exception(msg.c_str());
		}
	}
	else {
		create_comment();
	}
}

void article_reader::create_comment() {
	static const char *COMMENT_TEMPLATE = "<!-- generated by CROSSLINK/Translator with Google Translate, [EECS, SEF@QUT] on %s -->\n";
	const int MAXLEN = 80;
	char s[MAXLEN];
	time_t t = time(0);
	strftime(s, MAXLEN, "%d/%m/%Y %H:%M:%S", localtime(&t));
	string datetime(s);
	sprintf(s, COMMENT_TEMPLATE, datetime.c_str());
	writer->fill(s);
}

void article_reader::skip_external_links() {

}

void article_reader::init_token() {
}

void article_reader::copy_to_current(const char *start, const char *end) {
	writer->fill(start, end - start);
}







